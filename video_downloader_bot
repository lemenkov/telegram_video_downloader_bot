#!/usr/bin/python3

from telegram import Update
from telegram.error import NetworkError, BadRequest, TimedOut
from telegram.ext import ApplicationBuilder, CommandHandler, ContextTypes, MessageHandler, CallbackContext
import asyncio
import os
import yt_dlp

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    await update.message.reply_text(f'''Hello {update.effective_user.first_name}. Let's start.
    Available commands are:
    /start or /help
    /dl
                                ''')

async def download_video(addr: str) -> str:
    ydl_opts = {'format': 'mp4/best[ext=mp4]', 'cachedir': False}
    ydl = yt_dlp.YoutubeDL(ydl_opts)
    info = await asyncio.to_thread(ydl.extract_info, addr, download=False)
    filename = ydl.prepare_filename(info)
    await asyncio.to_thread(ydl.download, [addr])
    return filename

async def collect_info(update: Update, context: CallbackContext) -> None:
	pass
async def dl(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    if update.message.from_user.id not in ALLOWED_IDS:
        await update.message.reply_text(f"{update.effective_user.first_name} ({update.message.from_user.id}), you are not allowed to use this bot.")
    else:
        addr = update.message.text.split()[-1]
        await update.message.reply_text(f"Downloading {addr} ...", disable_web_page_preview=True)
        filename = await download_video(addr)
        file_size = os.path.getsize(filename)
        with open(filename, 'rb') as video:
            try:
                await context.bot.send_video(chat_id=update.message['chat']['id'], filename = filename, video = video, caption=f"Downloaded from: {addr}")
                print(f"{addr} sent as \"{filename}\"")
            except NetworkError as e:
                error_msg = str(e).lower()
                if "request entity too large" in error_msg or "payload too large" in error_msg:
                    await update.message.reply_text(
                            f"âŒ File too large for Telegram!\n"
                            f"ğŸ“ Size: {file_size / (1024*1024):.1f} MB\n"
                            f"ğŸ“‹ Limit: ~50 MB\n\n"
                            f"ğŸ”— Original: {addr}",
                            disable_web_page_preview=True
                    )
                    print(f"{addr} NOT sent: {str(e)}")
                elif "timeout" in error_msg:
                    await update.message.reply_text(
                            f"â° Upload timeout - file might be too large or connection slow\n"
                            f"ğŸ“ Size: {file_size / (1024*1024):.1f} MB"
                    )
                    print(f"{addr} NOT sent: {str(e)}")
                else:
                    await update.message.reply_text(f"ğŸŒ Network error: {str(e)}")
                    print(f"{addr} NOT sent: {str(e)}")
            except BadRequest as e:
                await update.message.reply_text(f"âŒ Bad request: {str(e)}")
                print(f"{addr} NOT sent: {str(e)}")
            except TimedOut:
                await update.message.reply_text(
                        f"â° Request timed out\n"
                        f"ğŸ“ File size: {file_size / (1024*1024):.1f} MB"
                )
                print(f"{addr} NOT sent: {str(e)}")
            except Exception as e:
                await update.message.reply_text(f"âŒ Unexpected error: {str(e)}")
                print(f"{addr} NOT sent: {str(e)}")
        os.remove(filename)

TOKEN=os.environ['TOKEN']
ALLOWED_IDS = list(map(int, os.environ['ALLOWED_IDS'].split(","))) if 'ALLOWED_IDS' in os.environ else []

app = ApplicationBuilder().token(TOKEN).build()

app.add_handler(CommandHandler("help", start))
app.add_handler(CommandHandler("start", start))
app.add_handler(CommandHandler("dl", dl))
app.add_handler(MessageHandler(filters = None, callback = collect_info))

app.run_polling()
